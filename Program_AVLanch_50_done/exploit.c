#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int           key;
    char          data;
    struct Node  *left, *right;
    int           height;
} Node;

// Utility to get node height
static int height(Node *n) {
    return n ? n->height : 0;
}

// Recompute height after child changes
static void update_height(Node *n) {
    int hl = height(n->left), hr = height(n->right);
    n->height = 1 + (hl > hr ? hl : hr);
}

// Right‐rotate subtree rooted at y
static Node* right_rotate(Node *y) {
    Node *x = y->left;
    Node *T2 = x->right;
    x->right = y;
    y->left  = T2;
    update_height(y);
    update_height(x);
    return x;
}

// Left‐rotate subtree rooted at x
static Node* left_rotate(Node *x) {
    Node *y = x->right;
    Node *T2 = y->left;
    y->left  = x;
    x->right = T2;
    update_height(x);
    update_height(y);
    return y;
}

/**
 * Insert key/data into the AVL rooted at node.
 * Count every single rotate() call in *rot_count.
 */
static Node* avl_insert(Node *node, int key, char data, int *rot_count) {
    if (!node) {
        Node *n = malloc(sizeof(Node));
        if (!n) { perror("malloc"); exit(1); }
        n->key    = key;
        n->data   = data;
        n->left   = n->right = NULL;
        n->height = 1;
        return n;
    }

    if (key < node->key) {
        node->left = avl_insert(node->left, key, data, rot_count);
    } else {
        node->right = avl_insert(node->right, key, data, rot_count);
    }

    update_height(node);
    int bal = height(node->left) - height(node->right);

    // LL
    if (bal > 1 && key < node->left->key) {
        node = right_rotate(node);
        (*rot_count)++;
    }
    // LR
    else if (bal > 1 && key > node->left->key) {
        node->left = left_rotate(node->left);
        (*rot_count)++;
        node = right_rotate(node);
        (*rot_count)++;
    }
    // RR
    else if (bal < -1 && key > node->right->key) {
        node = left_rotate(node);
        (*rot_count)++;
    }
    // RL
    else if (bal < -1 && key < node->right->key) {
        node->right = right_rotate(node->right);
        (*rot_count)++;
        node = left_rotate(node);
        (*rot_count)++;
    }

    return node;
}

int main(void) {
    FILE *fp = fopen("nodes.txt", "r");
    if (!fp) { perror("fopen nodes.txt"); return 1; }

    Node  *root     = NULL;
    char   line[128];
    char   flag[256];
    int    flag_len = 0;

    while (fgets(line, sizeof(line), fp)) {
        // strip newline
        line[strcspn(line, "\r\n")] = '\0';

        // split on first comma
        char *comma = strchr(line, ',');
        if (!comma) continue;
        *comma = '\0';
        int key = atoi(line);

        // data is the very next character after the comma
        char data = comma[1];

        // insert and count rotations
        int rotations = 0;
        root = avl_insert(root, key, data, &rotations);

        // if more than one single‐rotate was performed, collect this data
        if (rotations > 1) {
            flag[flag_len++] = data;
        }
    }
    fclose(fp);

    flag[flag_len] = '\0';
    printf("CWE{%s}\n", flag);
    return 0;
}