// sort_flag.c
// Reads 34‑byte records from input_stream.bin: a 2‑byte little‑endian key
// followed by a 32‑byte fragment. Sorts by key, XORs together all fragments
// at even indices in the sorted array, and prints the resulting ASCII flag.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>

#define RECORD_SIZE 34
#define PIECE_LEN   32

typedef struct {
    uint16_t value;           // 2‑byte little‑endian key
    uint8_t  piece[PIECE_LEN];// 32‑byte fragment
} Element;

// Comparator for qsort: sort by .value ascending
static int cmp_elem(const void *A, const void *B) {
    uint16_t a = ((const Element*)A)->value;
    uint16_t b = ((const Element*)B)->value;
    return (a < b) ? -1 : (a > b);
}

int main(void) {
    FILE *f = fopen("input_stream.bin", "rb");
    if (!f) {
        perror("fopen");
        return 1;
    }

    // Determine file size
    if (fseek(f, 0, SEEK_END) != 0) {
        perror("fseek");
        fclose(f);
        return 1;
    }
    long sz = ftell(f);
    if (sz < 0) {
        perror("ftell");
        fclose(f);
        return 1;
    }
    if (sz % RECORD_SIZE) {
        fprintf(stderr,
                "error: file size %ld is not a multiple of %d\n",
                sz, RECORD_SIZE);
        fclose(f);
        return 1;
    }
    size_t n = sz / RECORD_SIZE;
    rewind(f);

    // Read all records
    Element *arr = calloc(n, sizeof(Element));
    if (!arr) {
        perror("calloc");
        fclose(f);
        return 1;
    }
    for (size_t i = 0; i < n; ++i) {
        uint8_t buf[RECORD_SIZE];
        if (fread(buf, 1, RECORD_SIZE, f) != RECORD_SIZE) {
            fprintf(stderr, "read error at record %zu: %s\n",
                    i, strerror(errno));
            free(arr);
            fclose(f);
            return 1;
        }
        // Unpack 2‑byte little‑endian key
        arr[i].value = (uint16_t)buf[0]
                     | (uint16_t)buf[1] << 8;
        // Copy 32‑byte fragment
        memcpy(arr[i].piece, buf + 2, PIECE_LEN);
    }
    fclose(f);

    // Sort by key
    qsort(arr, n, sizeof(Element), cmp_elem);

    // XOR together all fragments at even indices
    uint8_t flag_buf[PIECE_LEN];
    memset(flag_buf, 0, PIECE_LEN);
    for (size_t i = 0; i < n; i += 2) {
        for (int j = 0; j < PIECE_LEN; ++j) {
            flag_buf[j] ^= arr[i].piece[j];
        }
    }

    // Null‑terminate and print ASCII flag
    char flag_str[PIECE_LEN + 1];
    memcpy(flag_str, flag_buf, PIECE_LEN);
    flag_str[PIECE_LEN] = '\0';
    printf("%s\n", flag_str);

    free(arr);
    return 0;
}